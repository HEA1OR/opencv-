



# 背景提取			

为了实现背景提取，首先要“学习”得出一个背景的模型。将模型和当前的画面进行对比，并且从其中将背景减除，减除后剩余的物体可以近似认为是前景物体			

通常背景被认为是场景中静态的或周期性移动的并在整个视察过程中保持静态或周期移动的部分				



## 背景提取的缺点			

对简单场景工作良好，但是有一个经常难以满足的假设：图像中每个像素的行为和其他像素的行为在统计上的独立的。			

为了对其邻域内的像素加以考虑，我们可以学习一个“多部份模型”，例如对独立像素模型稍加拓展，使其包含对其相邻像素的亮度的临时信息。			

可以使用邻域内像素的亮度来判断邻域像素是相对较亮还是较暗				

接下来对每个单独像素学习两个模型：一个邻域内较暗的模型，一个邻域内较亮的模型			

由于引入额外的开销，要避免使用更复杂的模型				

在像素独立假设不满足时，对结果中false-positive像素进行清理（cv::erode，cv::floodfill等）			

从现在开始，只考虑满足像素独立变化假设的情况					



## 场景建模			

一个新的前景物体会被置于“新的前景”层同时被标记为“正”物体或是一个空洞。			

在没有前景物体的区域，可以持续更新背景模型			

如果一个前景物体一段时间没有移动，它会被降级为“老的前景物体“，这是算法开始学习它的像素一些统计量，知道最后学到的模型和背景相结合，物体成为背景			



对于全局性的改变，例如点亮屋子里的灯，可能会使用全局帧间差分。会将很多像素的改变是为全局性的而非局部的变化，进而开始学习全新的模型				



## 像素				

对一条给定线上的像素如何随时间变化采样，直线迭代器cv::LineIterator实例化后可以按顺序提供一条直线上所有点的信息			

迭代器可以通过增量迭代的方式遍历端点之间直线上的每个像素，使用cv::LineIterator::operator++()来增量迭代			



## 帧间差分			

最简单的背景提取方法就是一帧减去另一帧，然后将”足够不同“的地方标为前景，这个过程会捕捉到物体的边缘			

忽略帧间微小的不同（小于15设为0）标记处大的不同（设为255）			

采用cv::erode()或连通分量方法对小噪音进行处理			



对彩色图片，对每个通道做帧间差分，然后使用cv::max()来合并各个通道的结果		



## 平均背景法				

平均法只是简单学习得到背景像素的均值和方差（或为计算迅速使用平均差）作为背景的模型				

FFAAD 帧间平均绝对差（比标准差稍微快一点				

FFAAD可以视为用来判断两个数据是否差异明显的距离度量				



得到背景模型，完成高低阙值的设定，就可以使用它对图像前景和背景（像素值位于背景模型的高低阙值之间的部分）的分割			

只有在三通道都出现强烈差异的像素才被标记为前景				



## 累计均值，方差和协方差				

事实上可以以增量的方式计算平均值				

### 使用cv::Mat::operator+=()计算均值			

### 使用cv::accumulate()计算均值			

可以自动实现cv::Mat::convertTo()功能，免去一个临时变量。还可以使用掩码图像，通过其他信息比如颜色判断是不是背景，比如颜色单调的高速公路使用掩膜方法			

### 变种：使用cv::accumulateWeighted()计算均值			

### 借助cv::accumulateSquare()计算方差				

### 使用cv::accumulateWeighted()计算协方差			

