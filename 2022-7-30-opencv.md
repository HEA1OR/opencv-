---
title: 'opencv学习'
date: 2022-7-30
permalink: 
tags:
  - study posts
  - opencv
  - C++

---
# 爱你孤身走暗巷~~    
## 正在播放陈奕迅《孤勇者》 💓💗●━━━━━━─────── ⇆ ↻ ㅤ ◁ ㅤㅤ❚❚ ㅤㅤ▷ 



# 滤波与卷积       
在这章将学到更高级的图像处理方法，不仅仅是对图像某个像素的值进行简单的改变。         
在图像结构体上根据图像像素之间的联系对峙进行高级处理。        

# 预备知识   
两个重要概念      
## 滤波，核和卷积       
滤波器指一种由一幅图像I(x，y)根据像素点x，y附近的区域计算得到一幅新图像I’(x，y)的算法     
模板规定滤波器的形状以及区域内像素的组成规律      
线性核：I’像素值由I及其周围的像素的值加权相加而来   
盒状核，规范化核，Sobel核，高斯核       

基于线性核的滤波等价于卷积    

（非线性核：   
如中值滤波器，将x，y处的值替换成核所覆盖区域的值的中位数   

## 锚点    
一般线性核中加粗点，对应与x，y乘   

# 边界外推和边界处理    
opencv的滤波操作得到的输出图像与源图像的形状相同    

一般通过自定义方式为源图像添加虚拟像素    

## 自定义边框    
cv::copyMakeBorder()是一个为图像创建边框的函数，指定源图像核扩充之后图像，指明填充方法，就会将第一幅图像填补后的结果保存在第二幅中    


## 自定义外推   
cv::borderInterpolate()       
一次计算一个维度上的外推，可以用于自定义copyMakeBorder

# 阙值化操作   
完成多层处理步骤并需要做出一个最终决定，或将高于或低于某一值的像素置零同时其他像素保持不变        

cv::threshold() 给定数组和阙值，可以看成用1x1的核进行卷积做非线性操作     

# Otsu算法   
可以自动决定最优的阙值    
简而言之，就是便利所有可能的阙值，然后对每个阙值结果的两类像素计算方差σ1（低于阙值的像素）和方差σ2（高于阙值的像素）        
使w1*σ1+w2*σ2 最小     
w1和w2是根据两类像素数量得出的权值    
（需要遍历所有阙值，并不高效）       


# 自适应阙值        
阙值在整个过程中自动产生变化，在cv::adaptiveThreshold()实现    
根据adaptivemethod设置两种不同自适应方法，都是逐个像素计算自适应阙值T(x，y)，通过计算每个司昂宿周围的bxb区域的加权平均值然后减去常数C   
ADAPTIVE_THRESH_MEAN_C：均值时权值相等      
ADAPTIVE_THRESH_GAUSSIAN_C权值更具其到中心点的距离通过高斯方程得到         

当图像中出现较大的明暗差异时，自适应阙值非常有效        
仅处理单通道8位或浮点型数据，且要求源图像与目标对象不同                  










# 这三天参加数学建模校内选拔赛，笔记可能会少一点         


## [写两句?](https://github.com/HEA1OR/HEA1OR.github.io/tree/master/_posts)


